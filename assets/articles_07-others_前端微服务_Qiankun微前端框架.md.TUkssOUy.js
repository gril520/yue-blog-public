import{_ as p,c as s,o as i,a4 as a}from"./chunks/framework.BCDg3NR7.js";const t="/yue-blog-public/assets/image-20240228134711174.CplIdDau.png",e="/yue-blog-public/assets/image-20240228135001110.cFSaiVW8.png",g="/yue-blog-public/assets/image-20240228135038824.piA0LFWv.png",o="/yue-blog-public/assets/image-20240228135204247.bmsF8eUt.png",m="/yue-blog-public/assets/image-20240228135449784.D9l-zVi0.png",n="/yue-blog-public/assets/image-20240228135630868.DzNG7UiW.png",l="/yue-blog-public/assets/image-20240228140222124.CPlcxT7w.png",c="/yue-blog-public/assets/image-20240228140357044.BELPenJQ.png",r="/yue-blog-public/assets/image-20240228141231749.BLqNY34P.png",u="/yue-blog-public/assets/image-20240228141324483.0ynFuUpn.png",_="/yue-blog-public/assets/image-20240228141412465.CHVgAC-r.png",b="/yue-blog-public/assets/image-20240228141836900.q0doAWuJ.png",y="/yue-blog-public/assets/image-20240228142241476.VlbL9j5N.png",k="/yue-blog-public/assets/image-20240228142345404.C-fK-Q1X.png",h="/yue-blog-public/assets/image-20240228142510071.DhAlUagp.png",d="/yue-blog-public/assets/image-20240228142547955.kvYfFRcW.png",q="/yue-blog-public/assets/image-20240228142640537.CuBdBQMe.png",Q="/yue-blog-public/assets/image-20240228094549720.BN_vEqmh.png",B="/yue-blog-public/assets/image-20240228095126005.3in7cvoR.png",P="/yue-blog-public/assets/image-20240228095502331.Bzll_scj.png",f="/yue-blog-public/assets/image-20240228095538098.DcoLy114.png",C="/yue-blog-public/assets/image-20240228095632825.ku8CPxFQ.png",D="/yue-blog-public/assets/image-20240228100210899.CEo2Jiit.png",S="/yue-blog-public/assets/image-20240228100055640.rZ-RC-sX.png",v="/yue-blog-public/assets/image-20240228100638531.CYy1gjPM.png",A="/yue-blog-public/assets/image-20240228102628670.EbFoWNRC.png",U="/yue-blog-public/assets/image-20240228103422474.c6Z27ame.png",x="/yue-blog-public/assets/image-20240228103732812.B390iZUO.png",M="/yue-blog-public/assets/image-20240228104141407.Be4S_cTh.png",T="/yue-blog-public/assets/image-20240228104802253.DOzpre-c.png",W="/yue-blog-public/assets/image-20240228104915677.C6nXmhhq.png",V="/yue-blog-public/assets/image-20240228105041766.BU2BXQiY.png",E="/yue-blog-public/assets/image-20240228105430888.C41GYUot.png",F="/yue-blog-public/assets/image-20240228110023313.Bge626SG.png",j="/yue-blog-public/assets/image-20240228110103578.Bbe04Xcj.png",J="/yue-blog-public/assets/image-20240228110833927.8KmUefjy.png",N="/yue-blog-public/assets/image-20240228110944994.BAMSbx_9.png",w="/yue-blog-public/assets/image-20240228111332889.B7P55IWT.png",L="/yue-blog-public/assets/image-20240228130325264.v9UwD1AZ.png",z="/yue-blog-public/assets/image-20240228130808416.BE1J2u7r.png",I="/yue-blog-public/assets/image-20240228131331156.VWmL2W3T.png",O="/yue-blog-public/assets/image-20240228131435029.BYuU9-3p.png",X="/yue-blog-public/assets/image-20240228131524460.H6PBh4Ab.png",Y="/yue-blog-public/assets/image-20240228131707174.MeTkvUU2.png",R="/yue-blog-public/assets/image-20240228131847561.BeczQFna.png",Z="/yue-blog-public/assets/image-20240228132239518.DQ4VvrHu.png",$="/yue-blog-public/assets/image-20240228132314858.BvqjjInW.png",G="/yue-blog-public/assets/image-20240228132451044.D48uok-d.png",H="/yue-blog-public/assets/image-20240228133834397.BD3gFZA0.png",K="/yue-blog-public/assets/image-20240228133248864.BgqKc1Wz.png",p2="/yue-blog-public/assets/image-20240228134013906.d0st8tXx.png",s2="/yue-blog-public/assets/image-20240228133531764.BMdpuMLD.png",u2=JSON.parse('{"title":"Qiankun 微前端框架","description":"","frontmatter":{},"headers":[],"relativePath":"articles/07-others/前端微服务/Qiankun微前端框架.md","filePath":"articles/07-others/前端微服务/Qiankun微前端框架.md","lastUpdated":1711329923000}'),i2={name:"articles/07-others/前端微服务/Qiankun微前端框架.md"},a2=a('<h1 id="qiankun-微前端框架" tabindex="-1">Qiankun 微前端框架 <a class="header-anchor" href="#qiankun-微前端框架" aria-label="Permalink to &quot;Qiankun 微前端框架&quot;">​</a></h1><h2 id="_1-简介" tabindex="-1">1.简介 <a class="header-anchor" href="#_1-简介" aria-label="Permalink to &quot;1.简介&quot;">​</a></h2><p>Qiankun 是一个面向微前端架构的 JavaScript 框架，由蚂蚁金服开发并维护。它旨在解决微前端架构下的应用集成、共享、隔离等问题，让前端应用更加灵活、可维护和可扩展。</p><p>Qiankun 提供了一种将多个独立的前端应用（微应用）组合成一个大型应用的方式，每个微应用都可以独立开发、构建、部署和运行。这些微应用可以是由不同团队开发，使用不同的技术栈实现的。</p><p>Qiankun 提供了以下核心功能：</p><ol><li><strong>应用注册与加载</strong>：Qiankun 提供了应用注册的 API，使得主应用可以动态加载并管理多个微应用。</li><li><strong>应用间通信</strong>：微应用之间和微应用与主应用之间可以通过 Qiankun 提供的通信机制进行通信，包括路由间的消息传递、状态共享等。</li><li><strong>样式隔离</strong>：Qiankun 通过 CSS Scoped 或 CSS Module 等技术来隔离各个微应用的样式，避免样式冲突。</li><li><strong>沙箱机制</strong>：Qiankun 使用沙箱机制隔离各个微应用的 JavaScript 执行环境，保证它们之间的安全性和稳定性。</li><li><strong>资源共享</strong>：Qiankun 提供了一种机制，可以让多个微应用共享同一份资源，如公共组件、公共库等。</li></ol><p>使用 Qiankun 可以使得前端项目更易于拆分和组合，提高了团队的开发效率和系统的可维护性。</p><h2 id="_2-qiankun搭建微前端场景" tabindex="-1">2.qiankun搭建微前端场景 <a class="header-anchor" href="#_2-qiankun搭建微前端场景" aria-label="Permalink to &quot;2.qiankun搭建微前端场景&quot;">​</a></h2><p>使用 Qiankun 搭建微前端架构是否有必要，取决于你的项目需求、团队规模和开发目标等因素。以下是一些考虑因素：</p><ol><li><strong>项目规模和复杂度</strong>：如果你的项目是单一的、规模不大，且没有明显的团队分工和代码复用需求，可能不需要引入微前端架构。</li><li><strong>团队分工和独立部署需求</strong>：如果你的团队分成多个子团队，每个子团队负责开发和维护不同的功能模块，或者每个团队都有独立的部署需求，那么微前端架构可能会更适合，Qiankun 正是为这种场景设计的。</li><li><strong>代码复用和共享资源需求</strong>：如果你希望多个项目之间可以共享一些代码、组件或者库，或者希望统一管理项目的依赖关系和版本，那么微前端架构可以提供更好的支持。</li><li><strong>技术栈统一性</strong>：虽然你提到多个项目都使用 Vue 开发，但如果团队中还有其他技术栈的项目，微前端架构可以提供一种统一的技术栈和开发模式。</li><li><strong>团队成员的熟悉程度</strong>：引入微前端架构会增加复杂度和学习成本，需要团队成员熟悉相关的概念和技术，因此需要权衡团队的技术水平和承受能力。</li></ol><p>总之，Qiankun 是为了解决多个独立前端项目集成的问题而设计的，如果你的项目存在上述需求，那么使用 Qiankun 搭建微前端架构可能会是一个不错的选择。但如果项目比较简单，且没有明显的团队分工和复用需求，引入微前端架构可能反而增加了不必要的复杂度。</p><h2 id="_3-qiankun-demo-微前端框架应用" tabindex="-1">3.qiankun-DEMO 微前端框架应用 <a class="header-anchor" href="#_3-qiankun-demo-微前端框架应用" aria-label="Permalink to &quot;3.qiankun-DEMO 微前端框架应用&quot;">​</a></h2><p>案例结构：</p><p><img src="'+t+'" alt="image-20240228134711174"></p><p>一个主应用，3个子应用；【main vue2】【vue2 vue3 react】</p><p><img src="'+e+'" alt="image-20240228135001110"></p><p>页面效果：</p><p><img src="'+g+'" alt="image-20240228135038824"></p><p><img src="'+o+'" alt="image-20240228135204247"></p><p>如何使用qiankun</p><p>1.主应用安装qiankun</p><p><img src="'+m+'" alt="image-20240228135449784"></p><p>2.入口文件配置</p><p><img src="'+n+'" alt="image-20240228135630868"></p><p><img src="'+l+'" alt="image-20240228140222124"></p><p>渲染容器</p><p><img src="'+c+'" alt="image-20240228140357044"></p><p>3.子应用配置 子应用如何接入乾坤</p><p><img src="'+r+'" alt="image-20240228141231749"></p><p>子应用入口文件</p><p><img src="'+u+'" alt="image-20240228141324483"></p><p><img src="'+_+'" alt="image-20240228141412465"></p><p>如果是微前端运行，主应用会把container传给子应用，并且将子应用挂载到主应用给的容器中渲染，否则独立渲染。</p><p><img src="'+b+'" alt="image-20240228141836900"></p><p>4.子应用跨域和webpack打包配置</p><p><img src="'+y+'" alt="image-20240228142241476"></p><p>5.react子应用</p><p><img src="'+k+'" alt="image-20240228142345404"></p><p><img src="'+h+'" alt="image-20240228142510071"></p><p><img src="'+d+'" alt="image-20240228142547955"></p><p>webpack适配</p><p><img src="'+q+'" alt="image-20240228142640537"></p><h2 id="_4-手写mini版乾坤" tabindex="-1">4.手写mini版乾坤 <a class="header-anchor" href="#_4-手写mini版乾坤" aria-label="Permalink to &quot;4.手写mini版乾坤&quot;">​</a></h2><p>实现registerMicroApps和start方法：</p><p><img src="'+Q+'" alt="image-20240228094549720"></p><p>路由监听：history路由模式=&gt;前进后退、添加历史记录、替换历史记录</p><p><img src="'+B+'" alt="image-20240228095126005"></p><p>封装代码：</p><p><img src="'+P+'" alt="image-20240228095502331"></p><p><img src="'+f+'" alt="image-20240228095538098"></p><p>封装处理路由变化逻辑</p><p><img src="'+C+'" alt="image-20240228095632825"></p><p>处理路由变化逻辑</p><p><img src="'+D+'" alt="image-20240228100210899"></p><p>初始执行匹配</p><p><img src="'+S+'" alt="image-20240228100055640"></p><p>加载子应用获取子应用资源</p><p><img src="'+v+'" alt="image-20240228100638531"></p><p>封装fetch</p><p><img src="'+A+'" alt="image-20240228102628670"></p><p>获取script代码</p><p><img src="'+U+'" alt="image-20240228103422474"></p><p>执行js代码</p><p><img src="'+x+'" alt="image-20240228103732812"></p><p>配置全局变量</p><p><img src="'+M+'" alt="image-20240228104141407"></p><p>打包子应用，并且分析umd文件</p><p><img src="'+T+'" alt="image-20240228104802253"></p><p><img src="'+W+'" alt="image-20240228104915677"></p><p>把结果返回</p><p><img src="'+V+'" alt="image-20240228105041766"></p><p>改进：</p><p><img src="'+E+'" alt="image-20240228105430888"></p><p>调用子应用的乾坤生命周期钩子</p><p><img src="'+F+'" alt="image-20240228110023313"></p><p>成功渲染结果：问题1：图片未被正确渲染</p><p><img src="'+j+'" alt="image-20240228110103578"></p><p>webpack打包是从入口模块开始打包的，子应用中，生命周期钩子必须写在入口模块中。</p><p>实现切换应用功能，涉及如何注销上一个应用；</p><p>路由监视，自己维护一个变量，用于存储上一个应用的路由</p><p><img src="'+J+'" alt="image-20240228110833927"></p><p><img src="'+N+'" alt="image-20240228110944994"></p><p>渲染下一个应用前先销毁上一个应用：</p><p><img src="'+w+'" alt="image-20240228111332889"></p><p><img src="'+L+'" alt="image-20240228130325264"></p><p>前进后退的路由维护，导航前导航后状态的维护。</p><p><img src="'+z+'" alt="image-20240228130808416"></p><p>子应用publicPath设置</p><p><img src="'+I+'" alt="image-20240228131331156"></p><p>图片问题解决：</p><p><img src="'+O+'" alt="image-20240228131435029"></p><p>请求的资源相对于当前页面的路径，即当前文档页面</p><p><img src="'+X+'" alt="image-20240228131524460"></p><p>目前这种写法直接就请求9000下的img了</p><p><img src="'+Y+'" alt="image-20240228131707174"></p><p>法一、指定域名</p><p><img src="'+R+'" alt="image-20240228131847561"></p><p>缺点，子应用只能运行在当前域名。</p><p><img src="'+Z+'" alt="image-20240228132239518"></p><p><img src="'+$+'" alt="image-20240228132314858"></p><p>设置全局变量</p><p><img src="'+G+'" alt="image-20240228132451044"></p><p>后续问题：处理样式隔离，JS沙箱</p><p>乾坤如何解决：</p><p>1.shadowDom隔离样式（shadowDOM兼容性不太好）</p><p><img src="'+H+'" alt="image-20240228133834397"></p><p><img src="'+K+'" alt="image-20240228133248864"></p><p>2.添加选择器</p><p><img src="'+p2+'" alt="image-20240228134013906"></p><p>演示：</p><p><img src="'+s2+'" alt="image-20240228133531764"></p>',111),t2=[a2];function e2(g2,o2,m2,n2,l2,c2){return i(),s("div",null,t2)}const _2=p(i2,[["render",e2]]);export{u2 as __pageData,_2 as default};
